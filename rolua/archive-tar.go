// Code generated by 'yaegi extract archive/tar'. DO NOT EDIT.

//go:build go1.24
// +build go1.24

package rolua

import (
	"archive/tar"
	"go/constant"
	"go/token"
	"io/fs"
	"reflect"
	"time"
)

func init() {
	Symbols["archive/tar/tar"] = map[string]reflect.Value{
		// function, constant and variable definitions
		"ErrFieldTooLong":    reflect.ValueOf(&tar.ErrFieldTooLong).Elem(),
		"ErrHeader":          reflect.ValueOf(&tar.ErrHeader).Elem(),
		"ErrInsecurePath":    reflect.ValueOf(&tar.ErrInsecurePath).Elem(),
		"ErrWriteAfterClose": reflect.ValueOf(&tar.ErrWriteAfterClose).Elem(),
		"ErrWriteTooLong":    reflect.ValueOf(&tar.ErrWriteTooLong).Elem(),
		"FileInfoHeader":     reflect.ValueOf(tar.FileInfoHeader),
		"FormatGNU":          reflect.ValueOf(tar.FormatGNU),
		"FormatPAX":          reflect.ValueOf(tar.FormatPAX),
		"FormatUSTAR":        reflect.ValueOf(tar.FormatUSTAR),
		"FormatUnknown":      reflect.ValueOf(tar.FormatUnknown),
		"NewReader":          reflect.ValueOf(tar.NewReader),
		"NewWriter":          reflect.ValueOf(tar.NewWriter),
		"TypeBlock":          reflect.ValueOf(constant.MakeFromLiteral("52", token.INT, 0)),
		"TypeChar":           reflect.ValueOf(constant.MakeFromLiteral("51", token.INT, 0)),
		"TypeCont":           reflect.ValueOf(constant.MakeFromLiteral("55", token.INT, 0)),
		"TypeDir":            reflect.ValueOf(constant.MakeFromLiteral("53", token.INT, 0)),
		"TypeFifo":           reflect.ValueOf(constant.MakeFromLiteral("54", token.INT, 0)),
		"TypeGNULongLink":    reflect.ValueOf(constant.MakeFromLiteral("75", token.INT, 0)),
		"TypeGNULongName":    reflect.ValueOf(constant.MakeFromLiteral("76", token.INT, 0)),
		"TypeGNUSparse":      reflect.ValueOf(constant.MakeFromLiteral("83", token.INT, 0)),
		"TypeLink":           reflect.ValueOf(constant.MakeFromLiteral("49", token.INT, 0)),
		"TypeReg":            reflect.ValueOf(constant.MakeFromLiteral("48", token.INT, 0)),
		"TypeRegA":           reflect.ValueOf(constant.MakeFromLiteral("0", token.INT, 0)),
		"TypeSymlink":        reflect.ValueOf(constant.MakeFromLiteral("50", token.INT, 0)),
		"TypeXGlobalHeader":  reflect.ValueOf(constant.MakeFromLiteral("103", token.INT, 0)),
		"TypeXHeader":        reflect.ValueOf(constant.MakeFromLiteral("120", token.INT, 0)),

		// type definitions
		"FileInfoNames": reflect.ValueOf((*tar.FileInfoNames)(nil)),
		"Format":        reflect.ValueOf((*tar.Format)(nil)),
		"Header":        reflect.ValueOf((*tar.Header)(nil)),
		"Reader":        reflect.ValueOf((*tar.Reader)(nil)),
		"Writer":        reflect.ValueOf((*tar.Writer)(nil)),

		// interface wrapper definitions
		"_FileInfoNames": reflect.ValueOf((*_archive_tar_FileInfoNames)(nil)),
	}
}

// _archive_tar_FileInfoNames is an interface wrapper for FileInfoNames type
type _archive_tar_FileInfoNames struct {
	IValue   interface{}
	WGname   func() (string, error)
	WIsDir   func() bool
	WModTime func() time.Time
	WMode    func() fs.FileMode
	WName    func() string
	WSize    func() int64
	WSys     func() any
	WUname   func() (string, error)
}

func (W _archive_tar_FileInfoNames) Gname() (string, error) {
	return W.WGname()
}
func (W _archive_tar_FileInfoNames) IsDir() bool {
	return W.WIsDir()
}
func (W _archive_tar_FileInfoNames) ModTime() time.Time {
	return W.WModTime()
}
func (W _archive_tar_FileInfoNames) Mode() fs.FileMode {
	return W.WMode()
}
func (W _archive_tar_FileInfoNames) Name() string {
	return W.WName()
}
func (W _archive_tar_FileInfoNames) Size() int64 {
	return W.WSize()
}
func (W _archive_tar_FileInfoNames) Sys() any {
	return W.WSys()
}
func (W _archive_tar_FileInfoNames) Uname() (string, error) {
	return W.WUname()
}
